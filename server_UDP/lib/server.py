import socket
import os
import sys
import json
import queue
import pickle
import time
import jsonpickle

from threading import Thread, Lock

from lib import errors_provider as error
from lib.db.db_connection import DataBase
from lib.request_handler import RequestHandler
from lib.model.chunk import Chunk
from lib.model.client import Client
from lib.model.server_update import ServerUpdate
from lib.model.character import Character

QUEUE_SIZE = 20
RECEIVE_TIMEOUT = 10
CHUNK_HEIGHT = 2160
CHUNK_WIDTH = 3840
CHARACTER_START_HEALTH = 100
CHARACTER_START_POSITION = (100, 100)


class ReceivePackagesThread(Thread):
    def __init__(self, sock, q, max_package):
        Thread.__init__(self)
        self.__socket = sock
        self.__queue = q
        self.__max_package = max_package
        self.__running = True

    def stop(self):
        self.__running = False

    def run(self):
        self.__socket.settimeout(RECEIVE_TIMEOUT)
        while self.__running:
            self.__get_package()

    def __get_package(self):
        try:
            package = self.__socket.recvfrom(self.__max_package)
            if package:
                self.__put_message(package)
        except socket.timeout:
            pass
        except Exception as e:
            print(f'Error receiving data from clients {e}')

    def __put_message(self, package):
        self.__queue.put(package)


class SendPackagesThread(Thread):
    def __init__(self, sock, q):
        Thread.__init__(self)
        self.__socket = sock
        self.__queue = q
        self.__running = True

    def stop(self):
        self.__running = False

    def run(self):
        while self.__running:
            self.__send_package()

    def __send_package(self):
        while not self.__queue.empty():
            data, address = self.__queue.get()
            self.__socket.sendto(data, address)


class Server(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.__IP_ADDRESS = None
        self.__PORT_NUMBER = None
        self.__MAX_HOSTS = None
        self.__MAX_PACKAGE = None
        self.__socket = None
        self.__received_packages = queue.Queue(QUEUE_SIZE)
        self.__packages_to_send = queue.Queue(QUEUE_SIZE)
        self.__connected_clients = []
        self.__config_file = 'config/server_config.json'
        self.__read_config()
        self.__db = DataBase()
        self.__bind_socket()
        self.__stopped = False
        self.__stop_signal_lock = Lock()
        self.__client_list_lock = Lock()
        self.__receiving_thread = ReceivePackagesThread(self.__socket, self.__received_packages, self.__MAX_PACKAGE)
        self.__receiving_thread.start()
        self.__sending_thread = SendPackagesThread(self.__socket, self.__packages_to_send)
        self.__sending_thread.start()
        self.__request_handler = RequestHandler(self)
        self.__map_height = 50000 # generated by server later
        self.__map_width = 50000 # generated by server later
        self.__chunks_list = []
        self.__create_chunks()
        self.__clients_characters = []
        print('Server initialized')

    def __create_chunks(self):
        pos_x = 0
        pos_y = 0
        while pos_y < self.__map_height:
            while pos_x < self.__map_width:
                self.__chunks_list.append(Chunk((pos_x + int(CHUNK_WIDTH / 2), pos_y + int(CHUNK_HEIGHT / 2))))
                pos_x = pos_x + CHUNK_WIDTH
            pos_x = 0
            pos_y = pos_y + CHUNK_HEIGHT

        for chunk in self.__chunks_list:
            print(chunk.position)

    def stop(self):
        self.__stop_signal_lock.acquire()
        self.__stopped = True
        self.__stop_signal_lock.release()

    def run(self):
        while not self.__check_stop():
            self.__check_received_packages()
            self.__check_clients_activity()
            self.__check_if_clients_need_update()
        self.__close_server()

    def __check_if_clients_need_update(self):
        need_update_clients = []
        for client in self.__connected_clients:
            if client.need_update():
                need_update_clients.append(client)
        for client in need_update_clients:
            self.__send_update_to_client(client)
            client.generate_next_update_time()

    def __send_update_to_client(self, client):
        client_addr = client.get_address()
        client_auth_key = client.get_auth_key()
        update_data = []
        package = ServerUpdate(client_auth_key, update_data)
        package = self.__serialize_object(package)
        self.__put_package_to_queue((package, client_addr))

    def __check_clients_activity(self):
        inactive_clients = []
        for client in self.__connected_clients:
            if not client.is_user_active():
                inactive_clients.append(client)
        for client in inactive_clients:
            self.__remove_client(client)

    def __remove_client(self, client):
        print("Removing client...")
        client_character = client.get_client_character()
        self.__remove_character_from_chunk(client_character)
        self.__clients_characters.remove(client_character)
        self.__connected_clients.remove(client)

    def __check_stop(self):
        self.__stop_signal_lock.acquire()
        result = self.__stopped
        self.__stop_signal_lock.release()
        return result

    def __read_config(self):
        if os.path.isfile(self.__config_file):
            with open(self.__config_file) as json_file:
                config_file = json.load(json_file)
                self.__IP_ADDRESS = config_file['ipAddress']
                self.__PORT_NUMBER = config_file['portNumber']
                self.__MAX_HOSTS = config_file['maxHosts']
                self.__MAX_PACKAGE = config_file['maxPackage']
        else:
            self.__handle_config_from_console()

    def __handle_config_from_console(self):
        print('There is no config file for server! Pass me interface, port number and max hosts')
        self.__IP_ADDRESS = input('Enter host IP x.x.x.x: ')
        self.__PORT_NUMBER = int(input('Enter port number: '))
        self.__MAX_HOSTS = int(input('Enter max hosts to connect with: '))

    def __bind_socket(self):
        try:
            self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.__socket.bind((self.__IP_ADDRESS, self.__PORT_NUMBER))
        except socket.error as msg:
            print(f'Failed binding specified interface {self.__IP_ADDRESS} and port {self.__PORT_NUMBER} error {msg}')
            sys.exit(error.WRONG_SOCKET)

    def __close_server(self):
        self.__inform_clients_about_close()
        self.__stop_receiving_thread()
        self.__stop_sending_thread()
        self.__db.close_connection()
        print("DEBUG end server thread")

    def __stop_receiving_thread(self):
        print(f'Stopping receiving thread...')
        self.__receiving_thread.stop()
        self.__receiving_thread.join(timeout=8)
        if self.__receiving_thread.isAlive():
            print('Receiving thread cannot be stopped')
        else:
            print("Receiving thread stopped")

    def __stop_sending_thread(self):
        print(f'Stopping sending thread...')
        self.__sending_thread.stop()
        self.__sending_thread.join(timeout=8)
        if self.__sending_thread.isAlive():
            print('Sending thread cannot be stopped')
        else:
            print("Sending thread stopped")

    def __inform_clients_about_close(self):
        self.__client_list_lock.acquire()
        print("Sending information to clients about closing server...")
        for client in self.__connected_clients:
            pass
        self.__client_list_lock.release()

    def __check_received_packages(self):
        if not self.__received_packages.empty():
            message = self.__received_packages.get()
            self.__handle_package(message)

    def __check_user(self, address, key):
        for client in self.__connected_clients:
            if client.get_address() == address and client.get_auth_key() == key:
                client.update_last_received_time(time.time())
                return True
            elif client.get_address() == address and client.get_auth_key() != key:
                return False
        return False

    def __find_client_character(self, nick):
        for character in self.__clients_characters:
            if character.nick == nick:
                return character
        return None

    def __create_new_character(self, nick):
        character = Character(nick, CHARACTER_START_HEALTH, CHARACTER_START_POSITION, [])
        self.__clients_characters.append(character)
        return character

    def __add_character_to_chunk(self, character):
        pos_x, pos_y = character.position
        chunks_in_row = int(self.__map_width/CHUNK_WIDTH)
        chunk_index = int(pos_x/CHUNK_WIDTH) + int(pos_y/CHUNK_WIDTH) * chunks_in_row
        self.__chunks_list[chunk_index].characters_list.append(character)
        print(f"Character added to chunk {chunk_index} at position: {self.__chunks_list[chunk_index].position}")

    def __remove_character_from_chunk(self, character):
        pos_x, pos_y = character.position
        chunks_in_row = int(self.__map_width / CHUNK_WIDTH)
        chunk_index = int(pos_x / CHUNK_WIDTH) + int(pos_y / CHUNK_WIDTH) * chunks_in_row
        self.__chunks_list[chunk_index].characters_list.remove(character)
        print(f"Character removed from chunk {chunk_index} at position: {self.__chunks_list[chunk_index].position}")

    def add_client(self, nick, address, key):
        print("Adding new client...")
        client_character = self.__find_client_character(nick)
        if client_character is None:
            client_character = self.__create_new_character(nick)
        self.__add_character_to_chunk(client_character)
        client = Client(nick, address, key, client_character)
        self.__connected_clients.append(client)
        return client

    def get_close_objects(self, character):
        close_objects = []
        chunk_indexes = []
        pos_x, pos_y = character.position
        chunks_in_row = int(self.__map_width / CHUNK_WIDTH)
        chunk_index = int(pos_x / CHUNK_WIDTH) + int(pos_y / CHUNK_WIDTH) * chunks_in_row
        return close_objects

    def __handle_package(self, package):
        print(package)
        package_to_send = self.__request_handler.handle_request(package)
        self.__put_package_to_queue(package_to_send),

    def __put_package_to_queue(self, package):
        self.__packages_to_send.put(package)

    @staticmethod
    def __get_key(data):
        try:
            return data['auth_key']
        except KeyError as e:
            print(f'Exception in parsing json file {e}')
            return None

    @staticmethod
    def __get_request_type(data):
        try:
            return data['type']
        except KeyError as e:
            print(f'Exception in parsing json file {e}')
            return None

    @staticmethod
    def __serialize_object(sending_object):
        return pickle.dumps(jsonpickle.encode(sending_object))

    @staticmethod
    def __deserialize_object(sending_object):
        return json.loads(pickle.loads(sending_object))
